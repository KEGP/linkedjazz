PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX xyz: <http://sparql.xyz/facade-x/data/>
PREFIX fx: <http://sparql.xyz/facade-x/ns/>

PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

PREFIX : <http://localhost:8080/ontology/kejazz/>
PREFIX res: <http://localhost:8080/resource/kejazz/>
PREFIX dul: <http://www.ontologydesignpatterns.org/ont/dul/DUL.owl#>

CONSTRUCT {
  [ a :RelationBetweenArtists;
    :includesSourceArtist ?sourceArtistMyNS;
    :includesTargetArtist ?targetArtistMyNS;
    :atTime [
      a dul:TimeInterval;
      :hasIntervalStartDate ?startDate;
      :hasIntervalEndDate ?endDate
    ];
    dul:satisfies ?aaRelationMyNS
  ].

  # RELATED ENTITIES

  # It may happen that the target artist isn't generated
  # by the artist.sparql query! That's why we need to create
  # again its triples here, using the limited amount of
  # information given inside the ArtistArtist relation data-structure
  # exposed by the MusicBrainz API.
  ?targetArtistMyNS a ?targetArtistClass;
    owl:sameAs ?targetArtistMBurl;
    :hasName ?targetArtistName;
    rdfs:label ?targetArtistName;
    :hasMusicBrainzID ?targetID.

  ?aaRelationMyNS a :RelationBetweenArtistsType;
    owl:sameAs ?musicbrainzRelationURL;
    rdfs:label ?relationType;
    :hasMusicBrainzID ?relationTypeID.

} WHERE {
  SERVICE<x-sparql-anything:>{
    # launch on musicbrainz/artist/
    fx:properties fx:location ?_name ;
                  fx:trim-strings "true"^^xsd:boolean .

    ?root a fx:root;
          xyz:artist ?artist_BN.

    {
      ?artist_BN xyz:id ?sourceID;
                 xyz:artist-relation-list/fx:anySlot ?relation_BN.
      ?relation_BN xyz:direction "forward";
                   xyz:target ?targetID;
                   xyz:artist ?targetArtist_BN.
      OPTIONAL {?targetArtist_BN xyz:name ?targetArtistName.}

      {?targetArtist_BN xyz:type "Person". BIND(:ArtistPerson as ?targetArtistClass).}
      UNION
      {?targetArtist_BN xyz:type "Group". BIND(:Band as ?targetArtistClass).}
      UNION
      {?targetArtist_BN xyz:type "Choir". BIND(:Choir as ?targetArtistClass).}
      UNION
      {?targetArtist_BN xyz:type "Orchestra". BIND(:Orchestra as ?targetArtistClass).}
      UNION
      {?targetArtist_BN xyz:type ?mbArtistType. FILTER(?mbArtistType NOT IN ("Person", "Group", "Choir", "Orchestra")). BIND(:ArtistGroup as ?targetArtistClass).}
    }
    UNION
    {
      ?artist_BN xyz:id ?targetID;
                 xyz:artist-relation-list/fx:anySlot ?relation_BN.
      ?relation_BN xyz:direction "backward";
                   xyz:target ?sourceID.
      OPTIONAL {?artist_BN xyz:name ?targetArtistName.}

      {?artist_BN xyz:type "Person". BIND(:ArtistPerson as ?targetArtistClass).}
      UNION
      {?artist_BN xyz:type "Group". BIND(:Band as ?targetArtistClass).}
      UNION
      {?artist_BN xyz:type "Choir". BIND(:Choir as ?targetArtistClass).}
      UNION
      {?artist_BN xyz:type "Orchestra". BIND(:Orchestra as ?targetArtistClass).}
      UNION
      {?artist_BN xyz:type ?mbArtistType. FILTER(?mbArtistType NOT IN ("Person", "Group", "Choir", "Orchestra")). BIND(:ArtistGroup as ?targetArtistClass).}
    }

    OPTIONAL{?relation_BN xyz:type ?relationType.}
    OPTIONAL{?relation_BN xyz:type-id ?relationTypeID.}
    OPTIONAL{?relation_BN xyz:begin ?startDate.}
    OPTIONAL{?relation_BN xyz:end ?endDate.}

    BIND(fx:entity(res:Artist, "/", ?sourceID) as ?sourceArtistMyNS).
    BIND(fx:entity(res:Artist, "/", ?targetID) as ?targetArtistMyNS).
    #BIND(fx:entity(res:RelationBetweenArtistsType, "/", REPLACE(?relationType, " ","_")) as ?aaRelationMyNS).
    BIND(fx:entity(res:RelationBetweenArtistsType, "/", ?relationTypeID) as ?aaRelationMyNS).

    BIND(fx:entity("https://musicbrainz.org/artist/", ?targetID) as ?targetArtistMBurl).
    BIND(fx:entity("https://musicbrainz.org/relationship/", ?relationTypeID) as ?musicbrainzRelationURL).
  }
}
