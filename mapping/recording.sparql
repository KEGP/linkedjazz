PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX xyz: <http://sparql.xyz/facade-x/data/>
PREFIX fx: <http://sparql.xyz/facade-x/ns/>

PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

PREFIX : <http://localhost:8080/ontology/kejazz/>
PREFIX res: <http://localhost:8080/resource/kejazz/>
PREFIX dul: <http://www.ontologydesignpatterns.org/ont/dul/DUL.owl#>

CONSTRUCT {
  ?recordingMyNS a :Recording;
    :hasTitle ?title;
    rdfs:label ?title;

    dul:realizes ?workMyNS;
    :hasDurationInMilliseconds ?trackLength;
    :isCreditedTo ?creditedArtistMyNS;
    :includedInRelease ?releaseMyNS;

    # Using a BN generated by SPARQL.Anything as a hack to avoid producing
    # duplicates of the same TimeInterval for each match caused by the WHERE clause:
    dul:hasTimeInterval ?work_BN;

    # IDENTIFICATION
    :hasMusicBrainzID ?mbID;
    :hasISRC ?isrc;
    owl:sameAs ?url;
    owl:sameAs ?musicbrainzRecordingURL.

  # RELATED ENTITIES

  # It may happen that the credited artist isn't generated
  # by the artist.sparql query! That's why we need to create
  # again its triples here, using the limited amount of
  # information given inside the artist-credit data-structure
  # exposed by the MusicBrainz API.
  ?creditedArtistMyNS a ?artistClass;
    :hasName ?artistName;
    rdfs:label ?artistName;
    owl:sameAs ?mbArtistURL;
    :hasMusicBrainzID ?creditedArtistMbID.

  ?work_BN a dul:TimeInterval;
    :hasIntervalStartDate ?performanceStartDate;
    :hasIntervalEndDate ?performanceEndDate.

} WHERE {
  SERVICE<x-sparql-anything:>{
    # launch on musicbrainz/recording
    fx:properties fx:location ?_name ;
                  fx:trim-strings "true"^^xsd:boolean .

    ?root a fx:root;
          xyz:recording ?recording_BN.
    ?recording_BN xyz:id ?mbID.

    OPTIONAL {?recording_BN xyz:title ?title.}
    OPTIONAL {?recording_BN xyz:length ?trackLength.}
    OPTIONAL {
      ?recording_BN xyz:artist-credit/fx:anySlot/xyz:artist ?artist_BN.
      ?artist_BN xyz:id ?creditedArtistMbID.
      
      OPTIONAL {?artist_BN xyz:name ?artistName.}

      {?artist_BN xyz:type "Person". BIND(:ArtistPerson as ?artistClass).}
      UNION
      {?artist_BN xyz:type "Group". BIND(:Band as ?artistClass).}
      UNION
      {?artist_BN xyz:type "Choir". BIND(:Choir as ?artistClass).}
      UNION
      {?artist_BN xyz:type "Orchestra". BIND(:Orchestra as ?artistClass).}
      UNION
      {?artist_BN xyz:type ?mbArtistType. FILTER(?mbArtistType NOT IN ("Person", "Group", "Choir", "Orchestra")). BIND(:ArtistGroup as ?artistClass).}
    }

    OPTIONAL {
      {?recording_BN xyz:isrc ?isrc.}
      UNION
      {?recording_BN xyz:isrc-list/fx:anySlot ?isrc.}
    }

    OPTIONAL {
      ?recording_BN xyz:work-relation-list/fx:anySlot ?work_BN.
      ?work_BN xyz:type "performance";
               xyz:type-id "a3005666-a872-32c3-ad06-98af558e99b0";
               xyz:target ?workMbID.
      OPTIONAL {?work_BN xyz:begin ?performanceStartDate.}
      OPTIONAL {?work_BN xyz:end ?performanceEndDate.}
    }
    OPTIONAL {
      ?recording_BN xyz:url-relation-list/fx:anySlot/xyz:target ?urlstr.
      BIND(fx:entity(?urlstr) as ?url).
    }
    
    OPTIONAL {
      ?recording_BN xyz:release-list/fx:anySlot ?release_BN.
      ?release_BN xyz:id ?releaseMbID.
    }

    BIND(fx:entity(res:Release, "/", ?releaseMbID) as ?releaseMyNS).
    BIND(fx:entity(res:Work, "/", ?workMbID) as ?workMyNS).
    BIND(fx:entity(res:Recording, "/", ?mbID) as ?recordingMyNS).
    BIND(fx:entity(res:Artist, "/", ?creditedArtistMbID) as ?creditedArtistMyNS).

    BIND(fx:entity("https://musicbrainz.org/artist/", ?creditedArtistMbID) as ?mbArtistURL).
    BIND(fx:entity("https://musicbrainz.org/recording/", ?mbID) as ?musicbrainzRecordingURL).
  }
}
